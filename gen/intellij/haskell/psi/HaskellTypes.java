// This is a generated file. Not intended for manual editing.
package intellij.haskell.psi;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import intellij.haskell.psi.impl.HaskellElementTypeFactory;
import intellij.haskell.psi.impl.*;

public interface HaskellTypes {

  IElementType HS_ANN_PRAGMA = new HaskellCompositeElementType("HS_ANN_PRAGMA");
  IElementType HS_CCONTEXT = new HaskellCompositeElementType("HS_CCONTEXT");
  IElementType HS_CFILES_PRAGMA = new HaskellCompositeElementType("HS_CFILES_PRAGMA");
  IElementType HS_CIDECLS = new HaskellCompositeElementType("HS_CIDECLS");
  IElementType HS_CLASS_DECLARATION = new HaskellCompositeElementType("HS_CLASS_DECLARATION");
  IElementType HS_CLAZZ = new HaskellCompositeElementType("HS_CLAZZ");
  IElementType HS_CNAME = new HaskellCompositeElementType("HS_CNAME");
  IElementType HS_COMMENTS = new HaskellCompositeElementType("HS_COMMENTS");
  IElementType HS_CON = new HaskellCompositeElementType("HS_CON");
  IElementType HS_CONID = HaskellElementTypeFactory.factory("HS_CONID");
  IElementType HS_CONOP = new HaskellCompositeElementType("HS_CONOP");
  IElementType HS_CONSTANT_FOLDED_PRAGMA = new HaskellCompositeElementType("HS_CONSTANT_FOLDED_PRAGMA");
  IElementType HS_CONSTR_1 = new HaskellCompositeElementType("HS_CONSTR_1");
  IElementType HS_CONSTR_2 = new HaskellCompositeElementType("HS_CONSTR_2");
  IElementType HS_CONSTR_3 = new HaskellCompositeElementType("HS_CONSTR_3");
  IElementType HS_CONSTR_4 = new HaskellCompositeElementType("HS_CONSTR_4");
  IElementType HS_CONSYM = HaskellElementTypeFactory.factory("HS_CONSYM");
  IElementType HS_CTYPE_PRAGMA = new HaskellCompositeElementType("HS_CTYPE_PRAGMA");
  IElementType HS_DATA_DECLARATION = new HaskellCompositeElementType("HS_DATA_DECLARATION");
  IElementType HS_DATA_DECLARATION_DERIVING = new HaskellCompositeElementType("HS_DATA_DECLARATION_DERIVING");
  IElementType HS_DEFAULT_DECLARATION = new HaskellCompositeElementType("HS_DEFAULT_DECLARATION");
  IElementType HS_DEPRECATED_WARN_PRAGMA = new HaskellCompositeElementType("HS_DEPRECATED_WARN_PRAGMA");
  IElementType HS_DERIVING_DECLARATION = new HaskellCompositeElementType("HS_DERIVING_DECLARATION");
  IElementType HS_DOT_DOT_PARENS = new HaskellCompositeElementType("HS_DOT_DOT_PARENS");
  IElementType HS_DUMMY_PRAGMA = new HaskellCompositeElementType("HS_DUMMY_PRAGMA");
  IElementType HS_EXPORT = new HaskellCompositeElementType("HS_EXPORT");
  IElementType HS_EXPORTS = new HaskellCompositeElementType("HS_EXPORTS");
  IElementType HS_EXPRESSION = new HaskellCompositeElementType("HS_EXPRESSION");
  IElementType HS_FIELDDECL = new HaskellCompositeElementType("HS_FIELDDECL");
  IElementType HS_FILE_HEADER = new HaskellCompositeElementType("HS_FILE_HEADER");
  IElementType HS_FILE_HEADER_PRAGMA = new HaskellCompositeElementType("HS_FILE_HEADER_PRAGMA");
  IElementType HS_FIXITY_DECLARATION = new HaskellCompositeElementType("HS_FIXITY_DECLARATION");
  IElementType HS_FOREIGN_DECLARATION = new HaskellCompositeElementType("HS_FOREIGN_DECLARATION");
  IElementType HS_GENERAL_PRAGMA_CONTENT = new HaskellCompositeElementType("HS_GENERAL_PRAGMA_CONTENT");
  IElementType HS_GTYCON = new HaskellCompositeElementType("HS_GTYCON");
  IElementType HS_HADDOCK_PRAGMA = new HaskellCompositeElementType("HS_HADDOCK_PRAGMA");
  IElementType HS_IMPORT_DECLARATION = new HaskellCompositeElementType("HS_IMPORT_DECLARATION");
  IElementType HS_IMPORT_DECLARATIONS = new HaskellCompositeElementType("HS_IMPORT_DECLARATIONS");
  IElementType HS_IMPORT_EMPTY_SPEC = new HaskellCompositeElementType("HS_IMPORT_EMPTY_SPEC");
  IElementType HS_IMPORT_HIDING = new HaskellCompositeElementType("HS_IMPORT_HIDING");
  IElementType HS_IMPORT_HIDING_SPEC = new HaskellCompositeElementType("HS_IMPORT_HIDING_SPEC");
  IElementType HS_IMPORT_ID = new HaskellCompositeElementType("HS_IMPORT_ID");
  IElementType HS_IMPORT_IDS_SPEC = new HaskellCompositeElementType("HS_IMPORT_IDS_SPEC");
  IElementType HS_IMPORT_PACKAGE_NAME = new HaskellCompositeElementType("HS_IMPORT_PACKAGE_NAME");
  IElementType HS_IMPORT_QUALIFIED = new HaskellCompositeElementType("HS_IMPORT_QUALIFIED");
  IElementType HS_IMPORT_QUALIFIED_AS = new HaskellCompositeElementType("HS_IMPORT_QUALIFIED_AS");
  IElementType HS_IMPORT_SPEC = new HaskellCompositeElementType("HS_IMPORT_SPEC");
  IElementType HS_INCLUDE_PRAGMA = new HaskellCompositeElementType("HS_INCLUDE_PRAGMA");
  IElementType HS_INCOHERENT_PRAGMA = new HaskellCompositeElementType("HS_INCOHERENT_PRAGMA");
  IElementType HS_INLINABLE_PRAGMA = new HaskellCompositeElementType("HS_INLINABLE_PRAGMA");
  IElementType HS_INLINE_FUSED_PRAGMA = new HaskellCompositeElementType("HS_INLINE_FUSED_PRAGMA");
  IElementType HS_INLINE_INNER_PRAGMA = new HaskellCompositeElementType("HS_INLINE_INNER_PRAGMA");
  IElementType HS_INLINE_PRAGMA = new HaskellCompositeElementType("HS_INLINE_PRAGMA");
  IElementType HS_INLINE_PRAGMAS = new HaskellCompositeElementType("HS_INLINE_PRAGMAS");
  IElementType HS_INST = new HaskellCompositeElementType("HS_INST");
  IElementType HS_INSTANCE_DECLARATION = new HaskellCompositeElementType("HS_INSTANCE_DECLARATION");
  IElementType HS_INSTVAR = new HaskellCompositeElementType("HS_INSTVAR");
  IElementType HS_KIND_SIGNATURE = new HaskellCompositeElementType("HS_KIND_SIGNATURE");
  IElementType HS_LANGUAGE_PRAGMA = new HaskellCompositeElementType("HS_LANGUAGE_PRAGMA");
  IElementType HS_LINE_PRAGMA = new HaskellCompositeElementType("HS_LINE_PRAGMA");
  IElementType HS_LIST_TYPE = new HaskellCompositeElementType("HS_LIST_TYPE");
  IElementType HS_MINIMAL_PRAGMA = new HaskellCompositeElementType("HS_MINIMAL_PRAGMA");
  IElementType HS_MODID = HaskellElementTypeFactory.factory("HS_MODID");
  IElementType HS_MODULE_BODY = new HaskellCompositeElementType("HS_MODULE_BODY");
  IElementType HS_MODULE_DECLARATION = new HaskellCompositeElementType("HS_MODULE_DECLARATION");
  IElementType HS_NEWCONSTR = new HaskellCompositeElementType("HS_NEWCONSTR");
  IElementType HS_NEWCONSTR_FIELDDECL = new HaskellCompositeElementType("HS_NEWCONSTR_FIELDDECL");
  IElementType HS_NEWTYPE_DECLARATION = new HaskellCompositeElementType("HS_NEWTYPE_DECLARATION");
  IElementType HS_NOINLINE_PRAGMA = new HaskellCompositeElementType("HS_NOINLINE_PRAGMA");
  IElementType HS_NOUNPACK_PRAGMA = new HaskellCompositeElementType("HS_NOUNPACK_PRAGMA");
  IElementType HS_OPTIONS_GHC_OPTION = new HaskellCompositeElementType("HS_OPTIONS_GHC_OPTION");
  IElementType HS_OPTIONS_GHC_PRAGMA = new HaskellCompositeElementType("HS_OPTIONS_GHC_PRAGMA");
  IElementType HS_OTHER_PRAGMA = new HaskellCompositeElementType("HS_OTHER_PRAGMA");
  IElementType HS_OVERLAP_PRAGMA = new HaskellCompositeElementType("HS_OVERLAP_PRAGMA");
  IElementType HS_QUALIFIER = new HaskellCompositeElementType("HS_QUALIFIER");
  IElementType HS_Q_CON = new HaskellCompositeElementType("HS_Q_CON");
  IElementType HS_Q_CON_QUALIFIER = new HaskellCompositeElementType("HS_Q_CON_QUALIFIER");
  IElementType HS_Q_CON_QUALIFIER_1 = new HaskellCompositeElementType("HS_Q_CON_QUALIFIER_1");
  IElementType HS_Q_CON_QUALIFIER_2 = new HaskellCompositeElementType("HS_Q_CON_QUALIFIER_2");
  IElementType HS_Q_CON_QUALIFIER_3 = new HaskellCompositeElementType("HS_Q_CON_QUALIFIER_3");
  IElementType HS_Q_CON_QUALIFIER_4 = new HaskellCompositeElementType("HS_Q_CON_QUALIFIER_4");
  IElementType HS_Q_NAME = new HaskellCompositeElementType("HS_Q_NAME");
  IElementType HS_Q_NAMES = new HaskellCompositeElementType("HS_Q_NAMES");
  IElementType HS_Q_VAR_CON = new HaskellCompositeElementType("HS_Q_VAR_CON");
  IElementType HS_RESERVED_ID = new HaskellCompositeElementType("HS_RESERVED_ID");
  IElementType HS_RULES_PRAGMA = new HaskellCompositeElementType("HS_RULES_PRAGMA");
  IElementType HS_SCC_PRAGMA = new HaskellCompositeElementType("HS_SCC_PRAGMA");
  IElementType HS_SCONTEXT = new HaskellCompositeElementType("HS_SCONTEXT");
  IElementType HS_SIMPLECLASS = new HaskellCompositeElementType("HS_SIMPLECLASS");
  IElementType HS_SIMPLETYPE = new HaskellCompositeElementType("HS_SIMPLETYPE");
  IElementType HS_SOURCE_PRAGMA = new HaskellCompositeElementType("HS_SOURCE_PRAGMA");
  IElementType HS_SPECIALIZE_PRAGMA = new HaskellCompositeElementType("HS_SPECIALIZE_PRAGMA");
  IElementType HS_SUB_CONSTR_2 = new HaskellCompositeElementType("HS_SUB_CONSTR_2");
  IElementType HS_TOP_DECLARATION = new HaskellCompositeElementType("HS_TOP_DECLARATION");
  IElementType HS_TTYPE = new HaskellCompositeElementType("HS_TTYPE");
  IElementType HS_TYPE_DECLARATION = new HaskellCompositeElementType("HS_TYPE_DECLARATION");
  IElementType HS_TYPE_FAMILY_DECLARATION = new HaskellCompositeElementType("HS_TYPE_FAMILY_DECLARATION");
  IElementType HS_TYPE_FAMILY_TYPE = new HaskellCompositeElementType("HS_TYPE_FAMILY_TYPE");
  IElementType HS_TYPE_INSTANCE_DECLARATION = new HaskellCompositeElementType("HS_TYPE_INSTANCE_DECLARATION");
  IElementType HS_TYPE_SIGNATURE = new HaskellCompositeElementType("HS_TYPE_SIGNATURE");
  IElementType HS_UNPACK_NOUNPACK_PRAGMA = new HaskellCompositeElementType("HS_UNPACK_NOUNPACK_PRAGMA");
  IElementType HS_UNPACK_PRAGMA = new HaskellCompositeElementType("HS_UNPACK_PRAGMA");
  IElementType HS_VAR = new HaskellCompositeElementType("HS_VAR");
  IElementType HS_VARID = HaskellElementTypeFactory.factory("HS_VARID");
  IElementType HS_VAROP = new HaskellCompositeElementType("HS_VAROP");
  IElementType HS_VARSYM = HaskellElementTypeFactory.factory("HS_VARSYM");
  IElementType HS_VAR_CON = new HaskellCompositeElementType("HS_VAR_CON");

  IElementType HS_AT = new HaskellTokenType("AT");
  IElementType HS_BACKQUOTE = new HaskellTokenType("BACKQUOTE");
  IElementType HS_BACKSLASH = new HaskellTokenType("BACKSLASH");
  IElementType HS_CASE = new HaskellTokenType("CASE");
  IElementType HS_CHARACTER_LITERAL = new HaskellTokenType("CHARACTER_LITERAL");
  IElementType HS_CLASS = new HaskellTokenType("CLASS");
  IElementType HS_COLON_COLON = new HaskellTokenType("COLON_COLON");
  IElementType HS_COMMA = new HaskellTokenType("COMMA");
  IElementType HS_COMMENT = new HaskellTokenType("COMMENT");
  IElementType HS_CONSYM_ID = new HaskellTokenType("CONSYM_ID");
  IElementType HS_CON_ID = new HaskellTokenType("CON_ID");
  IElementType HS_DATA = new HaskellTokenType("DATA");
  IElementType HS_DECIMAL = new HaskellTokenType("DECIMAL");
  IElementType HS_DEFAULT = new HaskellTokenType("DEFAULT");
  IElementType HS_DERIVING = new HaskellTokenType("DERIVING");
  IElementType HS_DIRECTIVE = new HaskellTokenType("DIRECTIVE");
  IElementType HS_DO = new HaskellTokenType("DO");
  IElementType HS_DOT = new HaskellTokenType("DOT");
  IElementType HS_DOT_DOT = new HaskellTokenType("DOT_DOT");
  IElementType HS_DOUBLE_RIGHT_ARROW = new HaskellTokenType("DOUBLE_RIGHT_ARROW");
  IElementType HS_ELSE = new HaskellTokenType("ELSE");
  IElementType HS_EQUAL = new HaskellTokenType("EQUAL");
  IElementType HS_FLOAT = new HaskellTokenType("FLOAT");
  IElementType HS_FOREIGN_EXPORT = new HaskellTokenType("FOREIGN_EXPORT");
  IElementType HS_FOREIGN_IMPORT = new HaskellTokenType("FOREIGN_IMPORT");
  IElementType HS_HADDOCK = new HaskellTokenType("HADDOCK");
  IElementType HS_HEXADECIMAL = new HaskellTokenType("HEXADECIMAL");
  IElementType HS_IF = new HaskellTokenType("IF");
  IElementType HS_IMPORT = new HaskellTokenType("IMPORT");
  IElementType HS_IN = new HaskellTokenType("IN");
  IElementType HS_INFIX = new HaskellTokenType("INFIX");
  IElementType HS_INFIXL = new HaskellTokenType("INFIXL");
  IElementType HS_INFIXR = new HaskellTokenType("INFIXR");
  IElementType HS_INSTANCE = new HaskellTokenType("INSTANCE");
  IElementType HS_LEFT_ARROW = new HaskellTokenType("LEFT_ARROW");
  IElementType HS_LEFT_BRACE = new HaskellTokenType("LEFT_BRACE");
  IElementType HS_LEFT_BRACKET = new HaskellTokenType("LEFT_BRACKET");
  IElementType HS_LEFT_PAREN = new HaskellTokenType("LEFT_PAREN");
  IElementType HS_LET = new HaskellTokenType("LET");
  IElementType HS_MODULE = new HaskellTokenType("MODULE");
  IElementType HS_NCOMMENT = new HaskellTokenType("NCOMMENT");
  IElementType HS_NCOMMENT_END = new HaskellTokenType("NCOMMENT_END");
  IElementType HS_NCOMMENT_START = new HaskellTokenType("NCOMMENT_START");
  IElementType HS_NEWLINE = new HaskellTokenType("NEWLINE");
  IElementType HS_NEWTYPE = new HaskellTokenType("NEWTYPE");
  IElementType HS_NHADDOCK = new HaskellTokenType("NHADDOCK");
  IElementType HS_OCTAL = new HaskellTokenType("OCTAL");
  IElementType HS_OF = new HaskellTokenType("OF");
  IElementType HS_PRAGMA_END = new HaskellTokenType("PRAGMA_END");
  IElementType HS_PRAGMA_START = new HaskellTokenType("PRAGMA_START");
  IElementType HS_QUASIQUOTE = new HaskellTokenType("QUASIQUOTE");
  IElementType HS_QUOTE = new HaskellTokenType("QUOTE");
  IElementType HS_RIGHT_ARROW = new HaskellTokenType("RIGHT_ARROW");
  IElementType HS_RIGHT_BRACE = new HaskellTokenType("RIGHT_BRACE");
  IElementType HS_RIGHT_BRACKET = new HaskellTokenType("RIGHT_BRACKET");
  IElementType HS_RIGHT_PAREN = new HaskellTokenType("RIGHT_PAREN");
  IElementType HS_SEMICOLON = new HaskellTokenType("SEMICOLON");
  IElementType HS_SHEBANG_LINE = new HaskellTokenType("SHEBANG_LINE");
  IElementType HS_STRING_LITERAL = new HaskellTokenType("STRING_LITERAL");
  IElementType HS_THEN = new HaskellTokenType("THEN");
  IElementType HS_TILDE = new HaskellTokenType("TILDE");
  IElementType HS_TYPE = new HaskellTokenType("TYPE");
  IElementType HS_TYPE_FAMILY = new HaskellTokenType("TYPE_FAMILY");
  IElementType HS_TYPE_INSTANCE = new HaskellTokenType("TYPE_INSTANCE");
  IElementType HS_UNDERSCORE = new HaskellTokenType("UNDERSCORE");
  IElementType HS_VARSYM_ID = new HaskellTokenType("VARSYM_ID");
  IElementType HS_VAR_ID = new HaskellTokenType("VAR_ID");
  IElementType HS_VERTICAL_BAR = new HaskellTokenType("VERTICAL_BAR");
  IElementType HS_WHERE = new HaskellTokenType("WHERE");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
       if (type == HS_ANN_PRAGMA) {
        return new HaskellAnnPragmaImpl(node);
      }
      else if (type == HS_CCONTEXT) {
        return new HaskellCcontextImpl(node);
      }
      else if (type == HS_CFILES_PRAGMA) {
        return new HaskellCfilesPragmaImpl(node);
      }
      else if (type == HS_CIDECLS) {
        return new HaskellCideclsImpl(node);
      }
      else if (type == HS_CLASS_DECLARATION) {
        return new HaskellClassDeclarationImpl(node);
      }
      else if (type == HS_CLAZZ) {
        return new HaskellClazzImpl(node);
      }
      else if (type == HS_CNAME) {
        return new HaskellCnameImpl(node);
      }
      else if (type == HS_COMMENTS) {
        return new HaskellCommentsImpl(node);
      }
      else if (type == HS_CON) {
        return new HaskellConImpl(node);
      }
      else if (type == HS_CONID) {
        return new HaskellConidImpl(node);
      }
      else if (type == HS_CONOP) {
        return new HaskellConopImpl(node);
      }
      else if (type == HS_CONSTANT_FOLDED_PRAGMA) {
        return new HaskellConstantFoldedPragmaImpl(node);
      }
      else if (type == HS_CONSTR_1) {
        return new HaskellConstr1Impl(node);
      }
      else if (type == HS_CONSTR_2) {
        return new HaskellConstr2Impl(node);
      }
      else if (type == HS_CONSTR_3) {
        return new HaskellConstr3Impl(node);
      }
      else if (type == HS_CONSTR_4) {
        return new HaskellConstr4Impl(node);
      }
      else if (type == HS_CONSYM) {
        return new HaskellConsymImpl(node);
      }
      else if (type == HS_CTYPE_PRAGMA) {
        return new HaskellCtypePragmaImpl(node);
      }
      else if (type == HS_DATA_DECLARATION) {
        return new HaskellDataDeclarationImpl(node);
      }
      else if (type == HS_DATA_DECLARATION_DERIVING) {
        return new HaskellDataDeclarationDerivingImpl(node);
      }
      else if (type == HS_DEFAULT_DECLARATION) {
        return new HaskellDefaultDeclarationImpl(node);
      }
      else if (type == HS_DEPRECATED_WARN_PRAGMA) {
        return new HaskellDeprecatedWarnPragmaImpl(node);
      }
      else if (type == HS_DERIVING_DECLARATION) {
        return new HaskellDerivingDeclarationImpl(node);
      }
      else if (type == HS_DOT_DOT_PARENS) {
        return new HaskellDotDotParensImpl(node);
      }
      else if (type == HS_DUMMY_PRAGMA) {
        return new HaskellDummyPragmaImpl(node);
      }
      else if (type == HS_EXPORT) {
        return new HaskellExportImpl(node);
      }
      else if (type == HS_EXPORTS) {
        return new HaskellExportsImpl(node);
      }
      else if (type == HS_EXPRESSION) {
        return new HaskellExpressionImpl(node);
      }
      else if (type == HS_FIELDDECL) {
        return new HaskellFielddeclImpl(node);
      }
      else if (type == HS_FILE_HEADER) {
        return new HaskellFileHeaderImpl(node);
      }
      else if (type == HS_FILE_HEADER_PRAGMA) {
        return new HaskellFileHeaderPragmaImpl(node);
      }
      else if (type == HS_FIXITY_DECLARATION) {
        return new HaskellFixityDeclarationImpl(node);
      }
      else if (type == HS_FOREIGN_DECLARATION) {
        return new HaskellForeignDeclarationImpl(node);
      }
      else if (type == HS_GENERAL_PRAGMA_CONTENT) {
        return new HaskellGeneralPragmaContentImpl(node);
      }
      else if (type == HS_GTYCON) {
        return new HaskellGtyconImpl(node);
      }
      else if (type == HS_HADDOCK_PRAGMA) {
        return new HaskellHaddockPragmaImpl(node);
      }
      else if (type == HS_IMPORT_DECLARATION) {
        return new HaskellImportDeclarationImpl(node);
      }
      else if (type == HS_IMPORT_DECLARATIONS) {
        return new HaskellImportDeclarationsImpl(node);
      }
      else if (type == HS_IMPORT_EMPTY_SPEC) {
        return new HaskellImportEmptySpecImpl(node);
      }
      else if (type == HS_IMPORT_HIDING) {
        return new HaskellImportHidingImpl(node);
      }
      else if (type == HS_IMPORT_HIDING_SPEC) {
        return new HaskellImportHidingSpecImpl(node);
      }
      else if (type == HS_IMPORT_ID) {
        return new HaskellImportIdImpl(node);
      }
      else if (type == HS_IMPORT_IDS_SPEC) {
        return new HaskellImportIdsSpecImpl(node);
      }
      else if (type == HS_IMPORT_PACKAGE_NAME) {
        return new HaskellImportPackageNameImpl(node);
      }
      else if (type == HS_IMPORT_QUALIFIED) {
        return new HaskellImportQualifiedImpl(node);
      }
      else if (type == HS_IMPORT_QUALIFIED_AS) {
        return new HaskellImportQualifiedAsImpl(node);
      }
      else if (type == HS_IMPORT_SPEC) {
        return new HaskellImportSpecImpl(node);
      }
      else if (type == HS_INCLUDE_PRAGMA) {
        return new HaskellIncludePragmaImpl(node);
      }
      else if (type == HS_INCOHERENT_PRAGMA) {
        return new HaskellIncoherentPragmaImpl(node);
      }
      else if (type == HS_INLINABLE_PRAGMA) {
        return new HaskellInlinablePragmaImpl(node);
      }
      else if (type == HS_INLINE_FUSED_PRAGMA) {
        return new HaskellInlineFusedPragmaImpl(node);
      }
      else if (type == HS_INLINE_INNER_PRAGMA) {
        return new HaskellInlineInnerPragmaImpl(node);
      }
      else if (type == HS_INLINE_PRAGMA) {
        return new HaskellInlinePragmaImpl(node);
      }
      else if (type == HS_INLINE_PRAGMAS) {
        return new HaskellInlinePragmasImpl(node);
      }
      else if (type == HS_INST) {
        return new HaskellInstImpl(node);
      }
      else if (type == HS_INSTANCE_DECLARATION) {
        return new HaskellInstanceDeclarationImpl(node);
      }
      else if (type == HS_INSTVAR) {
        return new HaskellInstvarImpl(node);
      }
      else if (type == HS_KIND_SIGNATURE) {
        return new HaskellKindSignatureImpl(node);
      }
      else if (type == HS_LANGUAGE_PRAGMA) {
        return new HaskellLanguagePragmaImpl(node);
      }
      else if (type == HS_LINE_PRAGMA) {
        return new HaskellLinePragmaImpl(node);
      }
      else if (type == HS_LIST_TYPE) {
        return new HaskellListTypeImpl(node);
      }
      else if (type == HS_MINIMAL_PRAGMA) {
        return new HaskellMinimalPragmaImpl(node);
      }
      else if (type == HS_MODID) {
        return new HaskellModidImpl(node);
      }
      else if (type == HS_MODULE_BODY) {
        return new HaskellModuleBodyImpl(node);
      }
      else if (type == HS_MODULE_DECLARATION) {
        return new HaskellModuleDeclarationImpl(node);
      }
      else if (type == HS_NEWCONSTR) {
        return new HaskellNewconstrImpl(node);
      }
      else if (type == HS_NEWCONSTR_FIELDDECL) {
        return new HaskellNewconstrFielddeclImpl(node);
      }
      else if (type == HS_NEWTYPE_DECLARATION) {
        return new HaskellNewtypeDeclarationImpl(node);
      }
      else if (type == HS_NOINLINE_PRAGMA) {
        return new HaskellNoinlinePragmaImpl(node);
      }
      else if (type == HS_NOUNPACK_PRAGMA) {
        return new HaskellNounpackPragmaImpl(node);
      }
      else if (type == HS_OPTIONS_GHC_OPTION) {
        return new HaskellOptionsGhcOptionImpl(node);
      }
      else if (type == HS_OPTIONS_GHC_PRAGMA) {
        return new HaskellOptionsGhcPragmaImpl(node);
      }
      else if (type == HS_OTHER_PRAGMA) {
        return new HaskellOtherPragmaImpl(node);
      }
      else if (type == HS_OVERLAP_PRAGMA) {
        return new HaskellOverlapPragmaImpl(node);
      }
      else if (type == HS_QUALIFIER) {
        return new HaskellQualifierImpl(node);
      }
      else if (type == HS_Q_CON) {
        return new HaskellQConImpl(node);
      }
      else if (type == HS_Q_CON_QUALIFIER) {
        return new HaskellQConQualifierImpl(node);
      }
      else if (type == HS_Q_CON_QUALIFIER_1) {
        return new HaskellQConQualifier1Impl(node);
      }
      else if (type == HS_Q_CON_QUALIFIER_2) {
        return new HaskellQConQualifier2Impl(node);
      }
      else if (type == HS_Q_CON_QUALIFIER_3) {
        return new HaskellQConQualifier3Impl(node);
      }
      else if (type == HS_Q_CON_QUALIFIER_4) {
        return new HaskellQConQualifier4Impl(node);
      }
      else if (type == HS_Q_NAME) {
        return new HaskellQNameImpl(node);
      }
      else if (type == HS_Q_NAMES) {
        return new HaskellQNamesImpl(node);
      }
      else if (type == HS_Q_VAR_CON) {
        return new HaskellQVarConImpl(node);
      }
      else if (type == HS_RESERVED_ID) {
        return new HaskellReservedIdImpl(node);
      }
      else if (type == HS_RULES_PRAGMA) {
        return new HaskellRulesPragmaImpl(node);
      }
      else if (type == HS_SCC_PRAGMA) {
        return new HaskellSccPragmaImpl(node);
      }
      else if (type == HS_SCONTEXT) {
        return new HaskellScontextImpl(node);
      }
      else if (type == HS_SIMPLECLASS) {
        return new HaskellSimpleclassImpl(node);
      }
      else if (type == HS_SIMPLETYPE) {
        return new HaskellSimpletypeImpl(node);
      }
      else if (type == HS_SOURCE_PRAGMA) {
        return new HaskellSourcePragmaImpl(node);
      }
      else if (type == HS_SPECIALIZE_PRAGMA) {
        return new HaskellSpecializePragmaImpl(node);
      }
      else if (type == HS_SUB_CONSTR_2) {
        return new HaskellSubConstr2Impl(node);
      }
      else if (type == HS_TOP_DECLARATION) {
        return new HaskellTopDeclarationImpl(node);
      }
      else if (type == HS_TTYPE) {
        return new HaskellTtypeImpl(node);
      }
      else if (type == HS_TYPE_DECLARATION) {
        return new HaskellTypeDeclarationImpl(node);
      }
      else if (type == HS_TYPE_FAMILY_DECLARATION) {
        return new HaskellTypeFamilyDeclarationImpl(node);
      }
      else if (type == HS_TYPE_FAMILY_TYPE) {
        return new HaskellTypeFamilyTypeImpl(node);
      }
      else if (type == HS_TYPE_INSTANCE_DECLARATION) {
        return new HaskellTypeInstanceDeclarationImpl(node);
      }
      else if (type == HS_TYPE_SIGNATURE) {
        return new HaskellTypeSignatureImpl(node);
      }
      else if (type == HS_UNPACK_NOUNPACK_PRAGMA) {
        return new HaskellUnpackNounpackPragmaImpl(node);
      }
      else if (type == HS_UNPACK_PRAGMA) {
        return new HaskellUnpackPragmaImpl(node);
      }
      else if (type == HS_VAR) {
        return new HaskellVarImpl(node);
      }
      else if (type == HS_VARID) {
        return new HaskellVaridImpl(node);
      }
      else if (type == HS_VAROP) {
        return new HaskellVaropImpl(node);
      }
      else if (type == HS_VARSYM) {
        return new HaskellVarsymImpl(node);
      }
      else if (type == HS_VAR_CON) {
        return new HaskellVarConImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
